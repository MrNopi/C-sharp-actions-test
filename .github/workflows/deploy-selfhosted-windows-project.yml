name: deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: self-hosted
    defaults:
      run:
        shell: powershell
        working-directory: MyNewTestProject
    env:
      DEPLOY_DIR: C:\apps\MyNewTestProject
      PUBLISH_TEMP: C:\apps\MyNewTestProject\publish
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Write env variables
        shell: powershell
        run: |
          Write-Host "DEPLOY_DIR=$env:DEPLOY_DIR"
          Write-Host "PUBLISH_TEMP=$env:PUBLISH_TEMP"

      - name: change workdir
        shell: powershell
        run: |
          Write-Host "workspace=${{ github.workspace }}"
          Get-Location
          Get-ChildItem

      - name: Restore
        run: |
          dotnet restore

      - name: Prepare publish temp directory
        run: |
          if (Test-Path $env:PUBLISH_TEMP) { Remove-Item -Recurse -Force $env:PUBLISH_TEMP }
          New-Item -ItemType Directory -Force -Path $env:PUBLISH_TEMP | Out-Null

      - name: Publish (Release)
        run: |
          dotnet publish MyNewTestProject.csproj -c Release -o $env:PUBLISH_TEMP

      # - name: Stop running Kestrel/dotnet for this app
      #   run: |
      #     $matches = Get-CimInstance Win32_Process |
      #       Where-Object { $_.CommandLine -match 'MyNewTestProject\.dll' -or $_.CommandLine -match 'MyNewTestProject\\MyNewTestProject' }
      #     if ($matches) {
      #       $matches | ForEach-Object {
      #         Write-Host "Stopping PID $($_.ProcessId): $($_.CommandLine)"
      #         Stop-Process -Id $_.ProcessId -Force -ErrorAction SilentlyContinue
      #       }
      #     } else {
      #       Write-Host "No existing Kestrel/dotnet process found for MyNewTestProject."
      #     }

      - name: Create deploy directory
        run: |
          if (-not (Test-Path $env:DEPLOY_DIR)) { New-Item -ItemType Directory -Force -Path $env:DEPLOY_DIR | Out-Null }


      - name: Transfer files to server
        shell: powershell
        env:
           DEPLOY_DIR: ${{ env.DEPLOY_DIR }}
           PUBLISH_TEMP: ${{ env.PUBLISH_TEMP }}
        run: | 
          $session = New-PSSession -ComputerName $Env:RemoteServer
          Invoke-Command -Session $session -ScriptBlock {
          Write-Host "Starting resource copying $ScriptPath ..."
          cd "C:/"
          Write-Host "Publish temp: " $env:PUBLISH_TEMP
          if (-not (Test-Path $env:PUBLISH_TEMP)) { New-Item -ItemType Directory -Force -Path $env:PUBLISH_TEMP | Out-Null }
          }
          Copy-Item -Path $env.PUBLISH_TEMP -Destination $RemotePath -ToSession $session
          Remove-PSSession $session


      - name: Deploy files to server
        shell: powershell
        run: | 
          $session = New-PSSession -ComputerName $env:RemoteServer
          Invoke-Command -Session $session -ScriptBlock {
          Write-Host "Starting deploy $ScriptPath ..."
          if ((Test-Path $env:PUBLISH_TEMP)) { 
          cd $env:PUBLISH_TEMP
           Start-Process "dotnet" -ArgumentList "`"$dll`" --urls http://0.0.0.0:8080" -WindowStyle Hidden
          | Out-Null }
          }
          Copy-Item -Path "$Env:PUBLISH_TEMP" -Destination "$Env:PUBLISH_TEMP" -ToSession $session
          Remove-PSSession $session

      # - name: Deploy (mirror published files)
      #   run: |
      #     robocopy "$env:PUBLISH_TEMP" "$env:DEPLOY_DIR" /MIR
      #     $code = $LASTEXITCODE
      #     if ($code -ge 8) { throw "robocopy failed with exit code $code" }
      #     # Normalize acceptable robocopy codes (0-7) so the step doesn't fail
      #     $global:LASTEXITCODE = 0

      # - name: Run app with logs (Kestrel)
      #   shell: powershell
      #   run: |
      #     $dll = Join-Path $env:DEPLOY_DIR 'MyNewTestProject.dll'
      #     if (-not (Test-Path $dll)) { throw "App DLL not found at $dll" }
      #     Write-Host "Starting app in background..."
      #     Start-Process "dotnet" -ArgumentList "`"$dll`" --urls http://0.0.0.0:8080" -WindowStyle Hidden
      #     Start-Sleep -Seconds 5
      #     Write-Host "âœ… App started in background on port 8080."



      - name: Healthcheck
        shell: powershell
        run: |
          $session = New-PSSession -ComputerName $Env.RemoteServer
          Invoke-Command -Session $session -ScriptBlock {
          Write-Host "Starting healthcheck..."
          $resp = Invoke-WebRequest -UseBasicParsing http://localhost:8080 -TimeoutSec 10
          $healthStatus = if ($resp.StatusCode -ne 200) { throw "Health check failed: $($resp.StatusCode)" }
          echo $healthStatus
          }
          Copy-Item -Path $env.PUBLISH_TEMP -Destination $RemotePath -ToSession $session
          Remove-PSSession $session
         
